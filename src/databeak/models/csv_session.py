# Apache License
# Version 2.0, January 2004
# http://www.apache.org/licenses/
#
# TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
#
# 1. Definitions.
#
# "License" shall mean the terms and conditions for use, reproduction,
# and distribution as defined by Sections 1 through 9 of this document.
#
# "Licensor" shall mean the copyright owner or entity granting the License.
#
# "Legal Entity" shall mean the union of the acting entity and all
# other entities that control, are controlled by, or are under common
# control with that entity. For the purposes of this definition,
# "control" means (i) the power, direct or indirect, to cause the
# direction or management of such entity, whether by contract or
# otherwise, or (ii) ownership of fifty percent (50%) or more of the
# outstanding shares, or (iii) beneficial ownership of such entity.
#
# "You" (or "Your") shall mean an individual or Legal Entity
# exercising permissions granted by this License.
#
# "Source" form shall mean the preferred form for making modifications,
# including but not limited to software source code, documentation
# source, and configuration files.
#
# "Object" form shall mean any form resulting from mechanical
# transformation or translation of a Source form, including but
# not limited to compiled object code, generated documentation,
# and conversions to other media types.
#
# "Work" shall mean the work of authorship, whether in Source or
# Object form, made available under the License, as indicated by a
# copyright notice that is included in or attached to the work
# (which shall not include communications that are individually
# marked or otherwise designated in writing by the copyright owner
# as "Not a Contribution").
#
# "Derivative Works" shall mean any work, whether in Source or Object
# form, that is based upon (or derived from) the Work and for which the
# editorial revisions, annotations, elaborations, or other modifications
# represent, as a whole, an original work of authorship. For the purposes
# of this License, Derivative Works shall not include works that remain
# separable from, or merely link (or bind by name) to the interfaces of,
# the Work and derivative works thereof.
#
# "Contribution" shall mean any work of authorship, including
# the original version of the Work and any modifications or additions
# to that Work or Derivative Works thereof, that is intentionally
# submitted to Licensor for inclusion in the Work by the copyright owner
# or by an individual or Legal Entity authorized to submit on behalf of
# the copyright owner. For the purposes of this definition, "submitted"
# means any form of electronic, verbal, or written communication sent
# to the Licensor or its representatives, including but not limited to
# communication on electronic mailing lists, source code control
# systems, and issue tracking systems that are managed by, or on behalf
# of, the Licensor for the purpose of discussing and improving the Work,
# but excluding communication that is conspicuously marked or otherwise
# designated in writing by the copyright owner as "Not a Contribution."
#
# 2. Grant of Copyright License. Subject to the terms and conditions of
# this License, each Contributor hereby grants to You a perpetual,
# worldwide, non-exclusive, no-charge, royalty-free, irrevocable
# copyright license to use, reproduce, modify, display, perform,
# sublicense, and distribute the Work and such Derivative Works in
# Source or Object form.
#
# 3. Grant of Patent License. Subject to the terms and conditions of
# this License, each Contributor hereby grants to You a perpetual,
# worldwide, non-exclusive, no-charge, royalty-free, irrevocable
# (except as stated in this section) patent license to make, have made,
# use, offer to sell, sell, import, and otherwise transfer the Work,
# where such license applies only to those patent claims licensable
# by such Contributor that are necessarily infringed by their
# Contribution(s) alone or by combination of their Contribution(s)
# with the Work to which such Contribution(s) was submitted. If You
# institute patent litigation against any entity (including a
# cross-claim or counterclaim in a lawsuit) alleging that the Work
# or a Contribution incorporated within the Work constitutes direct
# or contributory patent infringement, then any patent licenses
# granted to You under this License for that Work shall terminate
# as of the date such litigation is filed.
#
# 4. Redistribution. You may reproduce and distribute copies of the
# Work or Derivative Works thereof in any medium, with or without
# modifications, and in Source or Object form, provided that You
# meet the following conditions:
#
# (a) You must give any other recipients of the Work or
# Derivative Works a copy of this License; and
#
# (b) You must cause any modified files to carry prominent notices
# stating that You changed the files; and
#
# (c) You must retain, in the Source form of any Derivative Works
# that You distribute, all copyright, patent, trademark, and
# attribution notices from the Source form of the Work,
# excluding those notices that do not pertain to any part of
# the Derivative Works; and
#
# (d) If the Work includes a "NOTICE" text file as part of its
# distribution, then any Derivative Works that You distribute must
# include a readable copy of the attribution notices contained
# within such NOTICE file, excluding those notices that do not
# pertain to any part of the Derivative Works, in at least one
# of the following places: within a NOTICE text file distributed
# as part of the Derivative Works; within the Source form or
# documentation, if provided along with the Derivative Works; or,
# within a display generated by the Derivative Works, if and
# wherever such third-party notices normally appear. The contents
# of the NOTICE file are for informational purposes only and
# do not modify the License. You may add Your own attribution
# notices within Derivative Works that You distribute, alongside
# or as an addendum to the NOTICE text from the Work, provided
# that such additional attribution notices cannot be construed
# as modifying the License.
#
# You may add Your own copyright notice to Your modifications and
# may provide additional or different license terms and conditions
# for use, reproduction, or distribution of Your modifications, or
# for any such Derivative Works as a whole, provided Your use,
# reproduction, and distribution of the Work otherwise complies with
# the conditions stated in this License.
#
# 5. Submission of Contributions. Unless You explicitly state otherwise,
# any Contribution intentionally submitted for inclusion in the Work
# by You to the Licensor shall be under the terms and conditions of
# this License, without any additional terms or conditions.
# Notwithstanding the above, nothing herein shall supersede or modify
# the terms of any separate license agreement you may have executed
# with Licensor regarding such Contributions.
#
# 6. Trademarks. This License does not grant permission to use the trade
# names, trademarks, service marks, or product names of the Licensor,
# except as required for reasonable and customary use in describing the
# origin of the Work and reproducing the content of the NOTICE file.
#
# 7. Disclaimer of Warranty. Unless required by applicable law or
# agreed to in writing, Licensor provides the Work (and each
# Contributor provides its Contributions) on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied, including, without limitation, any warranties or conditions
# of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
# PARTICULAR PURPOSE. You are solely responsible for determining the
# appropriateness of using or redistributing the Work and assume any
# risks associated with Your exercise of permissions under this License.
#
# 8. Limitation of Liability. In no event and under no legal theory,
# whether in tort (including negligence), contract, or otherwise,
# unless required by applicable law (such as deliberate and grossly
# negligent acts) or agreed to in writing, shall any Contributor be
# liable to You for damages, including any direct, indirect, special,
# incidental, or consequential damages of any character arising as a
# result of this License or out of the use or inability to use the
# Work (including but not limited to damages for loss of goodwill,
# work stoppage, computer failure or malfunction, or any and all
# other commercial damages or losses), even if such Contributor
# has been advised of the possibility of such damages.
#
# 9. Accepting Warranty or Support. While redistributing the Work or
# Derivative Works thereof, You may choose to offer, and charge a fee
# for, acceptance of support, warranty, indemnity, or other liability
# obligations and/or rights consistent with this License. However, in
# accepting such obligations, You may act only on Your own behalf and on
# Your sole responsibility, not on behalf of any other Contributor, and
# only if You agree to indemnify, defend, and hold each Contributor
# harmless for any liability incurred by, or claims asserted against,
# such Contributor by reason of your accepting any such warranty or support.
#
# END OF TERMS AND CONDITIONS
#
# APPENDIX: How to apply the Apache License to your work.
#
# To apply the Apache License to your work, attach the following
# boilerplate notice, with the fields enclosed by brackets "[]"
# replaced with your own identifying information. (Don't include
# the brackets!)  The text should be enclosed in the appropriate
# comment syntax for the file format. We also recommend that a
# file or class name and description of purpose be included on the
# same "printed page" as the copyright notice for easier
# identification within third-party archives.
#
# Copyright [yyyy] [name of copyright owner]
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Session management for DataBeak MCP Server."""

from __future__ import annotations

import logging
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any
from uuid import uuid4

from pydantic_settings import BaseSettings

from ..exceptions import HistoryError, HistoryNotEnabledError
from .auto_save import AutoSaveConfig, AutoSaveManager
from .data_models import ExportFormat, OperationType, SessionInfo
from .data_session import DataSession
from .history_manager import HistoryManager, HistoryStorage
from .session_lifecycle import SessionLifecycle

if TYPE_CHECKING:
    import pandas as pd

logger = logging.getLogger(__name__)


class DataBeakSettings(BaseSettings):
    """Configuration settings for DataBeak sessions."""

    csv_history_dir: str = "."  # Default to current directory
    max_file_size_mb: int = 1024  # Default to 1024 MB
    session_timeout: int = 3600  # Default to 3600 seconds
    chunk_size: int = 10000  # Default to 10000 rows
    auto_save: bool = True  # Default to enabled

    model_config = {"env_prefix": "DATABEAK_", "case_sensitive": False}


# Global settings instance
_settings: DataBeakSettings | None = None


def get_csv_settings() -> DataBeakSettings:
    """Get or create the global DataBeak settings."""
    global _settings
    if _settings is None:
        _settings = DataBeakSettings()
    return _settings


class CSVSession:
    """Represents a single CSV editing session with focused responsibilities."""

    def __init__(
        self,
        session_id: str | None = None,
        ttl_minutes: int = 60,
        auto_save_config: AutoSaveConfig | None = None,
        enable_history: bool = True,
        history_storage: HistoryStorage = HistoryStorage.JSON,
    ):
        """Initialize a new CSV session."""
        self.session_id = session_id or str(uuid4())
        self.operations_history: list[dict[str, Any]] = []  # Keep for backward compatibility

        # Core components
        self.data_session = DataSession(self.session_id)
        self.lifecycle = SessionLifecycle(self.session_id, ttl_minutes)

        # Auto-save configuration
        self.auto_save_config = auto_save_config or AutoSaveConfig()
        self.auto_save_manager = AutoSaveManager(self.session_id, self.auto_save_config)

        # History management
        self.enable_history = enable_history
        settings = get_csv_settings()
        self.history_manager = (
            HistoryManager(
                session_id=self.session_id,
                storage_type=(history_storage if enable_history else HistoryStorage.MEMORY),
                history_dir=settings.csv_history_dir,
                enable_snapshots=True,
                snapshot_interval=5,  # Take snapshot every 5 operations
            )
            if enable_history
            else None
        )

    # Delegate to lifecycle manager
    def update_access_time(self) -> None:
        """Update the last accessed time."""
        self.lifecycle.update_access_time()
        self.data_session.update_access_time()

    def is_expired(self) -> bool:
        """Check if session has expired."""
        return self.lifecycle.is_expired()

    def load_data(self, df: pd.DataFrame, file_path: str | None = None) -> None:
        """Load data into the session."""
        self.data_session.load_data(df, file_path)
        self.update_access_time()
        self.record_operation(OperationType.LOAD, {"file_path": file_path, "shape": df.shape})

        # Update auto-save manager with original file path
        if file_path:
            self.auto_save_manager.original_file_path = file_path

    def get_info(self) -> SessionInfo:
        """Get session information."""
        data_info = self.data_session.get_data_info()
        lifecycle_info = self.lifecycle.get_lifecycle_info()

        return SessionInfo(
            session_id=self.session_id,
            created_at=lifecycle_info["created_at"],
            last_accessed=lifecycle_info["last_accessed"],
            row_count=data_info["shape"][0],
            column_count=data_info["shape"][1],
            columns=data_info["columns"],
            memory_usage_mb=data_info["memory_usage_mb"],
            operations_count=len(self.operations_history),
            file_path=data_info["file_path"],
        )

    def record_operation(
        self, operation_type: str | OperationType, details: dict[str, Any]
    ) -> None:
        """Record an operation in history."""
        # Handle both string and OperationType inputs
        operation_value = (
            operation_type.value if hasattr(operation_type, "value") else operation_type
        )

        # Legacy history (backward compatibility)
        self.operations_history.append(
            {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "type": operation_value,
                "details": details,
            }
        )
        self.update_access_time()

        # New persistent history
        if self.history_manager and self.data_session.df is not None:
            self.history_manager.add_operation(
                operation_type=operation_value,
                details=details,
                current_data=self.data_session.df,
                metadata={
                    "file_path": self.data_session.file_path,
                    "shape": (
                        self.data_session.df.shape if self.data_session.df is not None else (0, 0)
                    ),
                },
            )

        # Mark that auto-save is needed
        self.data_session.metadata["needs_autosave"] = True

    async def trigger_auto_save_if_needed(self) -> dict[str, Any] | None:
        """Trigger auto-save after operation if configured."""
        if self.auto_save_manager.should_save_after_operation() and self.data_session.metadata.get(
            "needs_autosave"
        ):
            result = await self.auto_save_manager.trigger_save(
                self._save_callback, "after_operation"
            )
            if result.get("success"):
                self.data_session.metadata["needs_autosave"] = False
            return result
        return None

    async def _save_callback(
        self, file_path: str, format: ExportFormat, encoding: str
    ) -> dict[str, Any]:
        """Callback for auto-save operations."""
        try:
            if self.data_session.df is None:
                return {"success": False, "error": "No data to save"}

            # Handle different export formats
            path_obj = Path(file_path)
            path_obj.parent.mkdir(parents=True, exist_ok=True)

            if format == ExportFormat.CSV:
                self.data_session.df.to_csv(path_obj, index=False, encoding=encoding)
            elif format == ExportFormat.TSV:
                self.data_session.df.to_csv(path_obj, sep="\t", index=False, encoding=encoding)
            elif format == ExportFormat.JSON:
                self.data_session.df.to_json(path_obj, orient="records", indent=2)
            elif format == ExportFormat.EXCEL:
                self.data_session.df.to_excel(path_obj, index=False)
            elif format == ExportFormat.PARQUET:
                self.data_session.df.to_parquet(path_obj, index=False)
            else:
                return {"success": False, "error": f"Unsupported format: {format}"}

            return {
                "success": True,
                "file_path": str(path_obj),
                "rows": len(self.data_session.df),
                "columns": len(self.data_session.df.columns),
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def rollback(self, steps: int = 1) -> bool:
        """Rollback operations by specified number of steps."""
        if self.data_session.original_df is None:
            return False

        if steps >= len(self.operations_history):
            # Rollback to original state
            self.data_session.df = self.data_session.original_df.copy()
            self.operations_history = []
            return True

        # This is a simplified rollback - in production, you'd replay operations
        logger.warning("Partial rollback not fully implemented")
        return False

    async def enable_auto_save(self, config: dict[str, Any]) -> dict[str, Any]:
        """Enable or update auto-save configuration."""
        try:
            # Update configuration
            self.auto_save_config = AutoSaveConfig.from_dict(config)
            self.auto_save_manager = AutoSaveManager(
                self.session_id,
                self.auto_save_config,
                self.data_session.file_path,  # Pass the original file path
            )

            # Start periodic save if needed
            if self.auto_save_config.enabled:
                await self.auto_save_manager.start_periodic_save(self._save_callback)

            return {
                "success": True,
                "message": "Auto-save configuration updated",
                "config": self.auto_save_config.to_dict(),
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    async def disable_auto_save(self) -> dict[str, Any]:
        """Disable auto-save."""
        try:
            await self.auto_save_manager.stop_periodic_save()
            self.auto_save_config.enabled = False
            return {"success": True, "message": "Auto-save disabled"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def get_auto_save_status(self) -> dict[str, Any]:
        """Get current auto-save status."""
        return self.auto_save_manager.get_status()

    async def manual_save(self) -> dict[str, Any]:
        """Manually trigger a save."""
        return await self.auto_save_manager.trigger_save(self._save_callback, "manual")

    async def undo(self) -> dict[str, Any]:
        """Undo the last operation."""
        if not self.history_manager:
            raise HistoryNotEnabledError(self.session_id)

        if not self.history_manager.can_undo():
            return {"success": False, "error": "No operations to undo"}

        try:
            operation, data_snapshot = self.history_manager.undo()

            if data_snapshot is not None and operation is not None:
                self.data_session.df = data_snapshot

                # Trigger auto-save if configured
                if self.auto_save_manager.should_save_after_operation():
                    await self.auto_save_manager.trigger_save(self._save_callback, "undo")

                return {
                    "success": True,
                    "message": f"Undid operation: {operation.operation_type}",
                    "operation": operation.to_dict(),
                    "can_undo": self.history_manager.can_undo(),
                    "can_redo": self.history_manager.can_redo(),
                }
            else:
                return {"success": False, "error": "No snapshot available for undo"}

        except HistoryNotEnabledError as e:
            logger.error(f"History operation failed: {e.message}")
            return {"success": False, "error": e.to_dict()}
        except Exception as e:
            logger.error(f"Unexpected error during undo: {e!s}")
            return {
                "success": False,
                "error": {"type": "UnexpectedError", "message": str(e)},
            }

    async def redo(self) -> dict[str, Any]:
        """Redo the previously undone operation."""
        if not self.history_manager:
            raise HistoryNotEnabledError(self.session_id)

        if not self.history_manager.can_redo():
            return {"success": False, "error": "No operations to redo"}

        try:
            operation, data_snapshot = self.history_manager.redo()

            if data_snapshot is not None and operation is not None:
                self.data_session.df = data_snapshot

                # Trigger auto-save if configured
                if self.auto_save_manager.should_save_after_operation():
                    await self.auto_save_manager.trigger_save(self._save_callback, "redo")

                return {
                    "success": True,
                    "message": f"Redid operation: {operation.operation_type}",
                    "operation": operation.to_dict(),
                    "can_undo": self.history_manager.can_undo(),
                    "can_redo": self.history_manager.can_redo(),
                }
            else:
                return {"success": False, "error": "No snapshot available for redo"}

        except HistoryNotEnabledError as e:
            logger.error(f"History operation failed: {e.message}")
            return {"success": False, "error": e.to_dict()}
        except Exception as e:
            logger.error(f"Unexpected error during redo: {e!s}")
            return {
                "success": False,
                "error": {"type": "UnexpectedError", "message": str(e)},
            }

    def get_history(self, limit: int | None = None) -> dict[str, Any]:
        """Get operation history."""
        if not self.history_manager:
            # Return legacy history if new history is not enabled
            return {
                "success": True,
                "history": (self.operations_history[-limit:] if limit else self.operations_history),
                "total": len(self.operations_history),
            }

        try:
            history = self.history_manager.get_history(limit)
            stats = self.history_manager.get_statistics()

            return {"success": True, "history": history, "statistics": stats}
        except HistoryError as e:
            logger.error(f"History operation failed: {e.message}")
            return {"success": False, "error": e.to_dict()}
        except Exception as e:
            logger.error(f"Unexpected error getting history: {e!s}")
            return {
                "success": False,
                "error": {"type": "UnexpectedError", "message": str(e)},
            }

    async def restore_to_operation(self, operation_id: str) -> dict[str, Any]:
        """Restore data to a specific operation point."""
        if not self.history_manager:
            raise HistoryNotEnabledError(self.session_id)

        try:
            data_snapshot = self.history_manager.restore_to_operation(operation_id)

            if data_snapshot is not None:
                self.df = data_snapshot

                # Trigger auto-save if configured
                if self.auto_save_manager.should_save_after_operation():
                    await self.auto_save_manager.trigger_save(self._save_callback, "restore")

                return {
                    "success": True,
                    "message": f"Restored to operation {operation_id}",
                    "shape": (
                        self.data_session.df.shape if self.data_session.df is not None else (0, 0)
                    ),
                }
            else:
                return {
                    "success": False,
                    "error": f"Could not restore to operation {operation_id}",
                }

        except HistoryNotEnabledError as e:
            logger.error(f"History operation failed: {e.message}")
            return {"success": False, "error": e.to_dict()}
        except Exception as e:
            logger.error(f"Unexpected error during restore: {e!s}")
            return {
                "success": False,
                "error": {"type": "UnexpectedError", "message": str(e)},
            }

    async def clear(self) -> None:
        """Clear session data to free memory."""
        # Stop auto-save if running
        await self.auto_save_manager.stop_periodic_save()

        # Clear history if enabled
        if self.history_manager:
            self.history_manager.clear_history()

        # Clear data session
        self.data_session.clear_data()
        self.operations_history.clear()


class SessionManager:
    """Manages multiple CSV sessions."""

    def __init__(self, max_sessions: int = 100, ttl_minutes: int = 60):
        """Initialize the session manager."""
        self.sessions: dict[str, CSVSession] = {}
        self.max_sessions = max_sessions
        self.ttl_minutes = ttl_minutes
        self.sessions_to_cleanup: set = set()

    def create_session(self) -> str:
        """Create a new session."""
        self._cleanup_expired()

        if len(self.sessions) >= self.max_sessions:
            # Remove oldest session
            oldest = min(self.sessions.values(), key=lambda s: s.lifecycle.last_accessed)
            del self.sessions[oldest.session_id]

        session = CSVSession(ttl_minutes=self.ttl_minutes)
        self.sessions[session.session_id] = session
        logger.info(f"Created new session: {session.session_id}")
        return session.session_id

    def get_session(self, session_id: str) -> CSVSession | None:
        """Get a session by ID."""
        session = self.sessions.get(session_id)
        if session and not session.is_expired():
            session.update_access_time()
            return session
        elif session and session.is_expired():
            # Mark for cleanup but don't remove synchronously
            self.sessions_to_cleanup.add(session_id)
        return None

    async def remove_session(self, session_id: str) -> bool:
        """Remove a session."""
        if session_id in self.sessions:
            await self.sessions[session_id].clear()
            del self.sessions[session_id]
            logger.info(f"Removed session: {session_id}")
            return True
        return False

    def list_sessions(self) -> list[SessionInfo]:
        """List all active sessions."""
        self._cleanup_expired()
        return [
            session.get_info()
            for session in self.sessions.values()
            if session.data_session.has_data()
        ]

    def _cleanup_expired(self) -> None:
        """Mark expired sessions for cleanup."""
        expired = [sid for sid, session in self.sessions.items() if session.is_expired()]
        self.sessions_to_cleanup.update(expired)
        if expired:
            logger.info(f"Marked {len(expired)} expired sessions for cleanup")

    async def cleanup_marked_sessions(self) -> None:
        """Clean up sessions marked for removal."""
        for session_id in list(self.sessions_to_cleanup):
            await self.remove_session(session_id)
            self.sessions_to_cleanup.discard(session_id)

    def get_or_create_session(self, session_id: str | None = None) -> CSVSession:
        """Get existing session or create new one."""
        if session_id:
            session = self.get_session(session_id)
            if session:
                return session

        new_session_id = self.create_session()
        return self.sessions[new_session_id]

    def export_session_history(self, session_id: str) -> dict[str, Any] | None:
        """Export session history as JSON."""
        session = self.get_session(session_id)
        if not session:
            return None

        return {
            "session_id": session.session_id,
            "created_at": session.lifecycle.created_at.isoformat(),
            "operations": session.operations_history,
            "metadata": session.data_session.metadata,
        }


# Global session manager instance
_session_manager: SessionManager | None = None


def get_session_manager() -> SessionManager:
    """Get or create the global session manager."""
    global _session_manager
    if _session_manager is None:
        _session_manager = SessionManager()
    return _session_manager
