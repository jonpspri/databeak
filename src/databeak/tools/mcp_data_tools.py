# Apache License
# Version 2.0, January 2004
# http://www.apache.org/licenses/
#
# TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
#
# 1. Definitions.
#
# "License" shall mean the terms and conditions for use, reproduction,
# and distribution as defined by Sections 1 through 9 of this document.
#
# "Licensor" shall mean the copyright owner or entity granting the License.
#
# "Legal Entity" shall mean the union of the acting entity and all
# other entities that control, are controlled by, or are under common
# control with that entity. For the purposes of this definition,
# "control" means (i) the power, direct or indirect, to cause the
# direction or management of such entity, whether by contract or
# otherwise, or (ii) ownership of fifty percent (50%) or more of the
# outstanding shares, or (iii) beneficial ownership of such entity.
#
# "You" (or "Your") shall mean an individual or Legal Entity
# exercising permissions granted by this License.
#
# "Source" form shall mean the preferred form for making modifications,
# including but not limited to software source code, documentation
# source, and configuration files.
#
# "Object" form shall mean any form resulting from mechanical
# transformation or translation of a Source form, including but
# not limited to compiled object code, generated documentation,
# and conversions to other media types.
#
# "Work" shall mean the work of authorship, whether in Source or
# Object form, made available under the License, as indicated by a
# copyright notice that is included in or attached to the work
# (which shall not include communications that are individually
# marked or otherwise designated in writing by the copyright owner
# as "Not a Contribution").
#
# "Derivative Works" shall mean any work, whether in Source or Object
# form, that is based upon (or derived from) the Work and for which the
# editorial revisions, annotations, elaborations, or other modifications
# represent, as a whole, an original work of authorship. For the purposes
# of this License, Derivative Works shall not include works that remain
# separable from, or merely link (or bind by name) to the interfaces of,
# the Work and derivative works thereof.
#
# "Contribution" shall mean any work of authorship, including
# the original version of the Work and any modifications or additions
# to that Work or Derivative Works thereof, that is intentionally
# submitted to Licensor for inclusion in the Work by the copyright owner
# or by an individual or Legal Entity authorized to submit on behalf of
# the copyright owner. For the purposes of this definition, "submitted"
# means any form of electronic, verbal, or written communication sent
# to the Licensor or its representatives, including but not limited to
# communication on electronic mailing lists, source code control
# systems, and issue tracking systems that are managed by, or on behalf
# of, the Licensor for the purpose of discussing and improving the Work,
# but excluding communication that is conspicuously marked or otherwise
# designated in writing by the copyright owner as "Not a Contribution."
#
# 2. Grant of Copyright License. Subject to the terms and conditions of
# this License, each Contributor hereby grants to You a perpetual,
# worldwide, non-exclusive, no-charge, royalty-free, irrevocable
# copyright license to use, reproduce, modify, display, perform,
# sublicense, and distribute the Work and such Derivative Works in
# Source or Object form.
#
# 3. Grant of Patent License. Subject to the terms and conditions of
# this License, each Contributor hereby grants to You a perpetual,
# worldwide, non-exclusive, no-charge, royalty-free, irrevocable
# (except as stated in this section) patent license to make, have made,
# use, offer to sell, sell, import, and otherwise transfer the Work,
# where such license applies only to those patent claims licensable
# by such Contributor that are necessarily infringed by their
# Contribution(s) alone or by combination of their Contribution(s)
# with the Work to which such Contribution(s) was submitted. If You
# institute patent litigation against any entity (including a
# cross-claim or counterclaim in a lawsuit) alleging that the Work
# or a Contribution incorporated within the Work constitutes direct
# or contributory patent infringement, then any patent licenses
# granted to You under this License for that Work shall terminate
# as of the date such litigation is filed.
#
# 4. Redistribution. You may reproduce and distribute copies of the
# Work or Derivative Works thereof in any medium, with or without
# modifications, and in Source or Object form, provided that You
# meet the following conditions:
#
# (a) You must give any other recipients of the Work or
# Derivative Works a copy of this License; and
#
# (b) You must cause any modified files to carry prominent notices
# stating that You changed the files; and
#
# (c) You must retain, in the Source form of any Derivative Works
# that You distribute, all copyright, patent, trademark, and
# attribution notices from the Source form of the Work,
# excluding those notices that do not pertain to any part of
# the Derivative Works; and
#
# (d) If the Work includes a "NOTICE" text file as part of its
# distribution, then any Derivative Works that You distribute must
# include a readable copy of the attribution notices contained
# within such NOTICE file, excluding those notices that do not
# pertain to any part of the Derivative Works, in at least one
# of the following places: within a NOTICE text file distributed
# as part of the Derivative Works; within the Source form or
# documentation, if provided along with the Derivative Works; or,
# within a display generated by the Derivative Works, if and
# wherever such third-party notices normally appear. The contents
# of the NOTICE file are for informational purposes only and
# do not modify the License. You may add Your own attribution
# notices within Derivative Works that You distribute, alongside
# or as an addendum to the NOTICE text from the Work, provided
# that such additional attribution notices cannot be construed
# as modifying the License.
#
# You may add Your own copyright notice to Your modifications and
# may provide additional or different license terms and conditions
# for use, reproduction, or distribution of Your modifications, or
# for any such Derivative Works as a whole, provided Your use,
# reproduction, and distribution of the Work otherwise complies with
# the conditions stated in this License.
#
# 5. Submission of Contributions. Unless You explicitly state otherwise,
# any Contribution intentionally submitted for inclusion in the Work
# by You to the Licensor shall be under the terms and conditions of
# this License, without any additional terms or conditions.
# Notwithstanding the above, nothing herein shall supersede or modify
# the terms of any separate license agreement you may have executed
# with Licensor regarding such Contributions.
#
# 6. Trademarks. This License does not grant permission to use the trade
# names, trademarks, service marks, or product names of the Licensor,
# except as required for reasonable and customary use in describing the
# origin of the Work and reproducing the content of the NOTICE file.
#
# 7. Disclaimer of Warranty. Unless required by applicable law or
# agreed to in writing, Licensor provides the Work (and each
# Contributor provides its Contributions) on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied, including, without limitation, any warranties or conditions
# of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
# PARTICULAR PURPOSE. You are solely responsible for determining the
# appropriateness of using or redistributing the Work and assume any
# risks associated with Your exercise of permissions under this License.
#
# 8. Limitation of Liability. In no event and under no legal theory,
# whether in tort (including negligence), contract, or otherwise,
# unless required by applicable law (such as deliberate and grossly
# negligent acts) or agreed to in writing, shall any Contributor be
# liable to You for damages, including any direct, indirect, special,
# incidental, or consequential damages of any character arising as a
# result of this License or out of the use or inability to use the
# Work (including but not limited to damages for loss of goodwill,
# work stoppage, computer failure or malfunction, or any and all
# other commercial damages or losses), even if such Contributor
# has been advised of the possibility of such damages.
#
# 9. Accepting Warranty or Support. While redistributing the Work or
# Derivative Works thereof, You may choose to offer, and charge a fee
# for, acceptance of support, warranty, indemnity, or other liability
# obligations and/or rights consistent with this License. However, in
# accepting such obligations, You may act only on Your own behalf and on
# Your sole responsibility, not on behalf of any other Contributor, and
# only if You agree to indemnify, defend, and hold each Contributor
# harmless for any liability incurred by, or claims asserted against,
# such Contributor by reason of your accepting any such warranty or support.
#
# END OF TERMS AND CONDITIONS
#
# APPENDIX: How to apply the Apache License to your work.
#
# To apply the Apache License to your work, attach the following
# boilerplate notice, with the fields enclosed by brackets "[]"
# replaced with your own identifying information. (Don't include
# the brackets!)  The text should be enclosed in the appropriate
# comment syntax for the file format. We also recommend that a
# file or class name and description of purpose be included on the
# same "printed page" as the copyright notice for easier
# identification within third-party archives.
#
# Copyright [yyyy] [name of copyright owner]
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""FastMCP data manipulation tool definitions for CSV Editor."""

from __future__ import annotations

from typing import Any, Literal

from fastmcp import Context

# Import type aliases
from .transformations import CellValue, FilterCondition, OperationResult
from .transformations import add_column as _add_column
from .transformations import change_column_type as _change_column_type
from .transformations import extract_from_column as _extract_from_column
from .transformations import fill_column_nulls as _fill_column_nulls
from .transformations import fill_missing_values as _fill_missing_values
from .transformations import filter_rows as _filter_rows
from .transformations import remove_columns as _remove_columns
from .transformations import remove_duplicates as _remove_duplicates
from .transformations import rename_columns as _rename_columns
from .transformations import replace_in_column as _replace_in_column
from .transformations import select_columns as _select_columns
from .transformations import sort_data as _sort_data
from .transformations import split_column as _split_column
from .transformations import strip_column as _strip_column
from .transformations import transform_column_case as _transform_column_case
from .transformations import update_column as _update_column


def register_data_tools(mcp: Any) -> None:
    """Register data manipulation tools with FastMCP server."""

    @mcp.tool
    async def filter_rows(
        session_id: str,
        conditions: list[FilterCondition],
        mode: str = "and",
        ctx: Context | None = None,
    ) -> OperationResult:
        """Filter rows using flexible conditions with comprehensive null value and text matching
        support.

        Provides powerful filtering capabilities optimized for AI-driven data analysis. Supports
        multiple operators, logical combinations, and comprehensive null value handling.

        Args:
            session_id: Session identifier for the active CSV data session
            conditions: List of filter conditions, each containing:
                       - column: Column name to filter on
                       - operator: Comparison operator (see supported operators below)
                       - value: Value to compare against (not needed for null operators)
            mode: Logic for combining conditions:
                  - "and": All conditions must be true (default)
                  - "or": Any condition can be true

        Supported Operators:
            Comparison: "=", "!=", ">", "<", ">=", "<="
            Text: "contains", "not_contains", "starts_with", "ends_with"
            Lists: "in", "not_in"
            Nulls: "is_null", "is_not_null" (no value parameter needed)

        Returns:
            Filtering operation result containing:
            - success: bool operation status
            - rows_before: Original row count
            - rows_after: Filtered row count
            - rows_filtered: Number of rows removed

        Examples:
            # Numeric filtering
            filter_rows(session_id, [{"column": "age", "operator": ">", "value": 25}])

            # Text filtering with null handling
            filter_rows(session_id, [
                {"column": "name", "operator": "contains", "value": "Smith"},
                {"column": "email", "operator": "is_not_null"}
            ], mode="and")

            # Multiple conditions with OR logic
            filter_rows(session_id, [
                {"column": "status", "operator": "=", "value": "active"},
                {"column": "priority", "operator": "=", "value": "high"}
            ], mode="or")

            # List membership and null filtering
            filter_rows(session_id, [
                {"column": "department", "operator": "in", "value": ["sales", "marketing"]},
                {"column": "phone", "operator": "is_null"}
            ])

        AI Usage Patterns:
            1. Start broad â†’ narrow with additional conditions
            2. Use get_value_counts first to understand data distribution
            3. Combine with sort_data for ordered results
            4. Use get_data_summary after filtering to verify results
        """
        return await _filter_rows(session_id, conditions, mode, ctx)

    @mcp.tool
    async def sort_data(
        session_id: str, columns: list[Any], ctx: Context | None = None
    ) -> dict[str, Any]:
        """Sort data by columns."""
        return await _sort_data(session_id, columns, ctx)

    @mcp.tool
    async def select_columns(
        session_id: str, columns: list[str], ctx: Context | None = None
    ) -> dict[str, Any]:
        """Select specific columns from the dataframe."""
        return await _select_columns(session_id, columns, ctx)

    @mcp.tool
    async def rename_columns(
        session_id: str, mapping: dict[str, str], ctx: Context | None = None
    ) -> dict[str, Any]:
        """Rename columns in the dataframe."""
        return await _rename_columns(session_id, mapping, ctx)

    @mcp.tool
    async def add_column(
        session_id: str,
        name: str,
        value: CellValue | list[CellValue] = None,
        formula: str | None = None,
        ctx: Context | None = None,
    ) -> OperationResult:
        """Add a new column to the dataframe."""
        return await _add_column(session_id, name, value, formula, ctx)

    @mcp.tool
    async def remove_columns(
        session_id: str, columns: list[str], ctx: Context | None = None
    ) -> dict[str, Any]:
        """Remove columns from the dataframe."""
        return await _remove_columns(session_id, columns, ctx)

    @mcp.tool
    async def change_column_type(
        session_id: str,
        column: str,
        dtype: str,
        errors: Literal["raise", "coerce"] = "coerce",
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Change the data type of a column."""
        return await _change_column_type(session_id, column, dtype, errors, ctx)

    @mcp.tool
    async def fill_missing_values(
        session_id: str,
        strategy: str = "drop",
        value: Any = None,
        columns: list[str] | None = None,
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Fill or remove missing values."""
        return await _fill_missing_values(session_id, strategy, value, columns, ctx)

    @mcp.tool
    async def remove_duplicates(
        session_id: str,
        subset: list[str] | None = None,
        keep: Literal["first", "last", "none"] = "first",
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Remove duplicate rows."""
        return await _remove_duplicates(session_id, subset, keep, ctx)

    @mcp.tool
    async def update_column(
        session_id: str,
        column: str,
        operation: str,
        value: Any | None = None,
        pattern: str | None = None,
        replacement: str | None = None,
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Update values in a specific column with simple operations like replace, extract, split,
        etc."""
        return await _update_column(session_id, column, operation, value, pattern, replacement, ctx)

    # Focused Column Operations
    @mcp.tool
    async def replace_in_column(
        session_id: str,
        column: str,
        pattern: str,
        replacement: str,
        regex: bool = True,
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Replace patterns in a column with replacement text.

        Args:
            session_id: Session identifier
            column: Column name to update
            pattern: Pattern to search for (regex or literal string)
            replacement: Replacement string
            regex: Whether to treat pattern as regex (default: True)

        Returns:
            Dict with success status and replacement info

        Examples:
            replace_in_column("session123", "name", r"Mr\\.", "Mister") -> Replace "Mr." with "Mister"
            replace_in_column("session123", "phone", r"\\D", "", True) -> Remove non-digits from phone
        """
        return await _replace_in_column(session_id, column, pattern, replacement, regex, ctx)

    @mcp.tool
    async def extract_from_column(
        session_id: str,
        column: str,
        pattern: str,
        expand: bool = False,
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Extract patterns from a column using regex.

        Args:
            session_id: Session identifier
            column: Column name to update
            pattern: Regex pattern to extract (use capturing groups)
            expand: Whether to expand to multiple columns if multiple groups

        Returns:
            Dict with success status and extraction info

        Examples:
            extract_from_column("session123", "email", r"(.+)@(.+)") -> Extract username and domain
            extract_from_column("session123", "code", r"([A-Z]{2})-(\\d+)") -> Extract prefix and number
        """
        return await _extract_from_column(session_id, column, pattern, expand, ctx)

    @mcp.tool
    async def split_column(
        session_id: str,
        column: str,
        delimiter: str = " ",
        part_index: int | None = None,
        expand_to_columns: bool = False,
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Split column values by delimiter.

        Args:
            session_id: Session identifier
            column: Column name to update
            delimiter: String to split on (default: space)
            part_index: Which part to keep (0-based index). None keeps first part
            expand_to_columns: Whether to expand splits into multiple columns

        Returns:
            Dict with success status and split info

        Examples:
            split_column("session123", "name", " ", 0) -> Keep first part of name
            split_column("session123", "full_name", " ", expand_to_columns=True) -> Split into multiple columns
        """
        return await _split_column(
            session_id, column, delimiter, part_index, expand_to_columns, ctx
        )

    @mcp.tool
    async def transform_column_case(
        session_id: str,
        column: str,
        transform: Literal["upper", "lower", "title", "capitalize"],
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Transform the case of text in a column.

        Args:
            session_id: Session identifier
            column: Column name to update
            transform: Type of case transformation

        Returns:
            Dict with success status and transformation info

        Examples:
            transform_column_case("session123", "name", "title") -> "john doe" becomes "John Doe"
            transform_column_case("session123", "code", "upper") -> "abc123" becomes "ABC123"
        """
        return await _transform_column_case(session_id, column, transform, ctx)

    @mcp.tool
    async def strip_column(
        session_id: str,
        column: str,
        chars: str | None = None,
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Strip whitespace or specified characters from column values.

        Args:
            session_id: Session identifier
            column: Column name to update
            chars: Characters to strip (None for whitespace)

        Returns:
            Dict with success status and strip info

        Examples:
            strip_column("session123", "name") -> Remove leading/trailing whitespace
            strip_column("session123", "code", "()") -> Remove parentheses from ends
        """
        return await _strip_column(session_id, column, chars, ctx)

    @mcp.tool
    async def fill_column_nulls(
        session_id: str, column: str, value: Any, ctx: Context | None = None
    ) -> dict[str, Any]:
        """Fill null/NaN values in a column with a specified value.

        Args:
            session_id: Session identifier
            column: Column name to update
            value: Value to use for filling nulls

        Returns:
            Dict with success status and fill info

        Examples:
            fill_column_nulls("session123", "age", 0) -> Replace NaN ages with 0
            fill_column_nulls("session123", "name", "Unknown") -> Replace missing names with "Unknown"
        """
        return await _fill_column_nulls(session_id, column, value, ctx)
